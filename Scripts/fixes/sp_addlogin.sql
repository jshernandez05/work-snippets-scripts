use sybsystemprocs
go
if exists(select 1
		from sysobjects
		where id=object_id('dbo.sp_addlogin')
		and type='P')
	drop procedure dbo.sp_addlogin
go

/* Sccsid = "%Z% generic/sproc/src/%M% %I% %G%" */
/*	4.8	1.1	06/14/90	sproc/src/addlogin */

/*
** Generated by spgenmsgs.pl on Thu Feb  2 00:39:14 2006 
*/
/*
** raiserror Messages for addlogin [Total 12]
**
** 17201, "'%1!' is not an official language name from syslanguages."
** 17240, "'%1!' is not a valid name."
** 17260, "Can't run %1! from within a transaction."
** 17262, "A user with the specified login name already exists."
** 17263, "Database name not valid -- login not added."
** 17265, "A role with the specified name '%1!' already exists in this Server."
** 17267, "Invalid value specified for %1! option. Login not created."
** 17756, "The execution of the stored procedure '%1!' in database '%2!' was aborted because there was an error in writing the replication log record."
** 18409, "The built-in function %1! failed. Please see the other messages printed along with this message."
** 18773, "HA_LOG: HA consistency check failure in stored procedure '%1!' on the companion server '%2!'."
** 18881, "Unable to generate %1! for HA use. Please Refer to documentation for details."
** 19257, "The authentication mechanism '%1!' is not valid."
** 19822, "A local temporary database is not permitted as the default database for a login."
*/
/*
** sp_getmessage Messages for addlogin [Total 3]
**
** 17262, "A user with the specified login name already exists."
** 17264, "New login created."
** 19259, "Warning. Authentication mechanism '%1!' is not enabled."
** 19446, "A login mapping for the name '%1!' already exists in this Server.
**		Drop an existing mapping before creating a new mapping."
** 19448, "An existing login mapping for user '%1!' allows only '%2!' authentication mechanism to be used."
** 18388, "You must be in the master database in order to run '%1!'."
*/
/*
** End spgenmsgs.pl output.
*/

/* 
** IMPORTANT: Please read the following instructions before
**   making changes to this stored procedure.
**
**	To make this stored procedure compatible with High Availability (HA),
**	changes to certain system tables must be propagated 
**	to the companion server under some conditions.
**	The tables include (but are not limited to):
**		syslogins, sysservers, sysattributes, systimeranges,
**		sysresourcelimits, sysalternates, sysdatabases,
**		syslanguages, sysremotelogins, sysloginroles,
**		sysalternates (master DB only), systypes (master DB only),
**		sysusers (master DB only), sysprotects (master DB only)
**	please refer to the HA documentation for detail.
**
**	Here is what you need to do: 
**	For each insert/update/delete statement, add three sections to
**	-- start HA transaction prior to the statement
**	-- add the statement
**	-- add HA synchronization code to propagate the change to the companion
**
**	For example, if you are adding 
**		insert master.dbo.syslogins ......
**	the code should look like:
**	1. Before that SQL statement:
**		
**	2. Now, the SQL statement:
**		insert master.dbo.syslogins ......
**	3. Add a HA synchronization section right after the SQL statement:
**		
**
**	You may need to do similar change for each built-in function you
**	want to add.
**
**	Finally, add a separate part at a place where it can not
**	be reached by the normal execution path:
**	clean_all:
**		
**		return (1)
*/

create procedure sp_addlogin
@loginame varchar(255),			/* login name of the new user */
@passwd varchar(256) = NULL,		/* password of the new user */
@defdb varchar(255) = "master",		/* default db for the new user */
@deflanguage varchar(255) = NULL,	/* default language for the new user */
@fullname varchar(255) = NULL,		/* account owner's full name */
@passwdexp int = NULL,			/* value of password expiration */
@minpwdlen int = NULL,			/* value of minimum password 
					** length 
					*/
@maxfailedlogins int = NULL,		/* value of maximum failed 
					** logins
					*/
@auth_mech varchar(30) = "ANY"		/* Authentication mechanism */
as

declare @msg varchar(1024)
declare @dummy int,
	@passeclass int,		/* Class id in Sysattributes */
	@attrib int,			/* attribute id in 
					** Sysatttributes
					*/
	@action int,			/* Insert, update or delete 
					** Sysattributes entry
					*/
	@retstat int,
	@insertsuid int,		/* suid corresponding to 
					** insert slot in Syslogins
					*/
	@HA_CERTIFIED tinyint,		/* Is the SP HA certified ? */
	@authid int,			/* auth mechanism id */
	@config int,			/* Config option for external
					** authentication mechanisms.
					*/
	@status	int,			/* Syslogins status */
	@curname varchar(30),		/* To retrieve name from syslogins */
	@login_class int,		/* To retrieve mapping from
					** sysattributes. 
					*/
	@login_attrib int,		/* To retrieve mapping */
	@map_authid int,		/* sp_maplogin auth mechanism id */
	@map_authnm  varchar(30),	/* sp_maplogin auth mechanism name */

	@maxlen int,
	@log_for_rep int,
	@db_rep_level_all int,
	@db_rep_level_none int,
	@db_rep_level_l1 int,
	@lt_rep_get_failed int


/* 
** HA uses sp_halockclustertables procedure to handle concurrency.
** Use of cursors in a HA cluster leads to a significant drop in the
** addlogin performance.
*/
declare sync_cursor cursor for select name from master.dbo.syslogins holdlock for update


/*
** Initialize some constants
*/
select @db_rep_level_all = -1,
       @db_rep_level_none = 0,
       @db_rep_level_l1 = 1,
       @lt_rep_get_failed = -2

select @HA_CERTIFIED = 0	



/* check to see if we are using HA specific SP for a HA enabled server */
exec @retstat = sp_ha_check_certified 'sp_addlogin', @HA_CERTIFIED
if (@retstat != 0)
	return (1)


/*
** Do not allow this system procedure to be run from within a transaction
** to avoid creating a multi-database transaction where the 'master'
** database is not the co-ordinating database.
*/
if @@trancount > 0
begin
	/*
	** 17260, "Can't run %1! from within a transaction."
	*/
	raiserror 17260, "sp_addlogin"
	return (1)
end
else
begin
	set chained off
end
set transaction isolation level 1

/*
** Get the replication status of the 'master' database
*/
select @log_for_rep = getdbrepstat(1) 
if (@log_for_rep = @lt_rep_get_failed)
begin
	raiserror 18409, "getdbrepstat"
	return (1)
end

/*
** Convert the replication status to a boolean
*/
if (@log_for_rep != @db_rep_level_none)
	select @log_for_rep = 1
else
	select @log_for_rep = 0

/*
** If we are logging this system procedure for replication, we must be in
** the 'master' database to avoid creating a multi-database transaction
** which could make recovery of the 'master' database impossible.
*/
if (@log_for_rep = 1) and (db_name() != "master")
begin
	/*
	** 18388, "You must be in the master database in order to run '%1!'."
	*/
	raiserror 18388, "sp_addlogin"
	return (1)
end

/* check if user has sso role, proc_role will also do auditing
** if required. proc_role will also print error message if required.
*/

if (proc_role("sso_role") = 0)
	return (1)

declare @returncode	int

/*
**  Check to see that the @loginame is valid.
*/
if (@loginame is not null)
begin
	select @maxlen = length from master.dbo.syscolumns
	where id = object_id("master.dbo.syslogins") and name = "name"

	if (valid_name(@loginame, @maxlen) = 0) or
	   (@loginame = 'dbo')
	begin
		/*
		** 17240, "'%1!' is not a valid name." 
		*/
		raiserror 17240, @loginame
		return 1
	end
end

/*
** Check to see that the @fullname is valid.
*/
if (@fullname is not NULL) 
begin
	select @maxlen = length from master.dbo.syscolumns
	where id = object_id("master.dbo.syslogins") and name = "fullname"

	if char_length(@fullname) > @maxlen
	begin
		/*
		** 17240, "'%1!' is not a valid name."
		*/
		raiserror 17240, @fullname
		return 1
	end
end

if @deflanguage is not null
begin
	select @returncode = 0
	execute @returncode = sp_validlang @deflanguage
	if @returncode != 0
	begin
		/* Us_english is always valid */
		if @deflanguage != "us_english"
		begin
			/*
			** 17201, "'%1!' is not an official language name from Syslanguages." 
			*/
			raiserror 17201, @deflanguage
			return @returncode
		end
	end
end


open sync_cursor
/*
** To serialize concurrent sp_addlogin requests
*/
fetch sync_cursor into @curname


/*
**  Make sure the login or login profile name doesn't already exist.
*/
if exists (select *
	from master.dbo.syslogins (index ncsyslogins)
	where name = @loginame)
begin
	/*
	** 17262, "A user with the specified login name already exists."
	*/
	raiserror 17262
	return (1)
end

/*
** Make sure role doesn't already exist with this name.
*/
if exists (select * 
	from master.dbo.syssrvroles
	where name = @loginame)
begin
	/*
	** 17265, "A role with the specified name '%1!' already exists in this
	**	   Server."
	*/
	raiserror 17265, @loginame
	return (1)
end

/*
** Make sure a login mapping doesn't already exist for this name.
** Prevent a login from being added if there already exists a 
** mapping that may obscure the login. This helps to avoid
** another way to alias a user within ASE.
*/
select @login_class = 20, @login_attrib = 0

if exists (select 1 from master.dbo.sysattributes where
			class = @login_class and attribute = @login_attrib and 
			object_cinfo = @loginame)
begin	
	/*
	** 19446, "A login mapping for the name '%1!' already exists in this
	**	   Server.  Drop an existing mapping before creating a new 
	**	   mapping."
	*/
	raiserror 19446, @loginame
	return (1)
end

/*
**  Check that the database name is valid.
**  If it was specified as NULL then default it to "master".  Note that this
**  can happen for 'sp_addlogin peter, password, null, null, "peter rabbit"'
**  but not for 'sp_addlogin peter, password, @fullname = "peter rabbit"'.
*/
if @defdb is NULL
begin
	select @defdb = "master"
end

if not exists (select *
	from master.dbo.sysdatabases
	where name = @defdb)
begin
	/*
	** 17263, "Database name not valid -- login not added."
	*/
	raiserror 17263
	return (1)
end

/*
**  Check that the database name is useable on all instances of cluster.
**  If specified default database is a local temporary database then
**  fail the command to avoid problems at connection time.
*/
if db_instanceid(db_id(@defdb)) is not null
begin
	/*
	** 19822, "A local temporary database is not permitted as the 
	** default database for a login."
	*/
	raiserror 19822
	return (1)
end

/* Assign the class number for the 
** PASSWORD_SECURITY class in
** master.dbo.sysattributes
*/
select @passeclass = 14



exec @retstat = sp_gen_login_id @loginame, @insertsuid output
if (@retstat != 0)
	goto clean_all


  
/*
** delete entries for local mapped logins 
** from sysattributes for this login.  
** This will cleanup the rows having stale object suid 
** equal to this newly generated suid (insertsuid) 
*/
delete from master.dbo.sysattributes
	where object = @insertsuid
	and object_type = "LM"



/* If any of the password options have been
** specified, check for validity & insert
** appropriate entry in Sysattributes
*/
if @passwdexp is not NULL
begin
	select  @attrib = 0,
		@action = 1
	if attrib_valid(@passeclass, @attrib, "PS", @insertsuid, 
		NULL, NULL, NULL, "login", @passwdexp, NULL, NULL, NULL,
		NULL, @action) = 0
	begin
		/*
		** 17267, "Invalid 'password expiration' attribute specified.
		** Login not created."
		*/
		raiserror 17267, "password expiration"
		goto clean_all
	end
	else
	begin
		insert into master.dbo.sysattributes(class, attribute,
			object_type, object_cinfo, object, int_value)
		values
		(@passeclass, @attrib, "PS", "login", @insertsuid, @passwdexp)


	
	end
end

if @minpwdlen is not NULL
begin
        select  @attrib = 1,
		@action = 1
        if attrib_valid(@passeclass, @attrib, "PS", @insertsuid, 
                NULL, NULL, NULL, "login", @minpwdlen, NULL, NULL, NULL,
                NULL, @action) = 0
        begin
		/* 
		** 17267, "Incorrect 'minimum password length' attribute
		** specified. Login not created."
		*/
		raiserror 17267, "minimum password length"
                goto clean_all
        end
        else
	begin
                insert into master.dbo.sysattributes(class, attribute,
                        object_type, object_cinfo, object, int_value)
                values
                (@passeclass, @attrib, "PS", "login", @insertsuid, 
			@minpwdlen)



	end
end


if @maxfailedlogins is not NULL
begin
        select  @attrib = 2,
		@action = 1
        if attrib_valid(@passeclass, @attrib, "PS", @insertsuid, 
                NULL, NULL, NULL, "login", @maxfailedlogins, NULL, NULL, 
                NULL, NULL, @action) = 0
        begin
		/* 
		** 17267, "Incorrect 'maximum failed logins' specified.
		** Login not created."
		*/
		raiserror 17267, "maximum failed logins"
		goto clean_all
        end
        else
	begin
	        insert into master.dbo.sysattributes(class, attribute,
                        object_type, object_cinfo, object, int_value)
                values
                (@passeclass, @attrib, "PS", "login", @insertsuid, 
			@maxfailedlogins)



	end
end

/*
** Check whether authentication mechanism specified is valid or not.
** 'AUTH_DEFAULT' and 'AUTH_MASK' are new values added in spt_values
** used to obtain value of default ('ANY') authmech or authentication
** mask respectively. They are not valid names that the user can specify
** as authentication mechanism.
*/
select  @authid = low, @config = number
from master.dbo.spt_values
where type = 'ua' and name = upper(@auth_mech) and
upper(@auth_mech) not in ('AUTH_DEFAULT', 'AUTH_MASK')

if @@rowcount = 0
begin
	/*
	** 19257, "The authentication mechanism '%1!' is not valid."
	*/
	raiserror 19257, @auth_mech
	goto clean_all
end

/*
** If authmech is 'ANY', then obtain the value of default authmech
** 'ASE_DEFAULT' defined in spt_values.
*/
if (upper(@auth_mech) = "ANY")
begin
	select @authid = low from master.dbo.spt_values
		where type = 'ua' and name = "AUTH_DEFAULT"
end

/*
** Check if the authentication method is enabled.
*/
if (@config != 0) and not exists(select 1
	from master.dbo.syscurconfigs a
	where a.config = @config and a.value != 0)
begin
	/*
	** 19259, "Warning. Authentication mechanism '%1!' is not enabled."
	*/
	exec sp_getmessage 19259, @msg output
	print @msg, @auth_mech
end

/* Set status to LOGIN_LOCKED | Authentication mask */
select @status = 2 | @authid 

/*
**  Create the login.  Lock the account temporarily and
**  Put in a dont-care NULL as password.
*/
insert into master.dbo.syslogins (suid, status, accdate, totcpu, totio,
        spacelimit, timelimit, resultlimit,
        dbname, name, password, language,
        pwdate, audflags, fullname)
values ( @insertsuid, @status, getdate(), 0, 0, 0, 0, 0,
        @defdb, @loginame , NULL, @deflanguage,
        getdate(), 0, @fullname )





/*
**  Encrypt and store the input password
*/
execute @returncode = sp_password NULL, @passwd, @loginame



if (@returncode = 0)
begin
	/*
	** Before we log our system procedure execution instance,
	** re-initialize the '@password' parameter to the encrypted form of
	** the password.  This prevents the password from being stored in
	** clear text in the transaction log as well as in the Replication
	** Server stable queues.
	**
	** When the ASE RepAgent Thread sends the system procedure
	** execution instance to the Replication Server, the ASE RepAgent
	** will re-name the system procedure from 'sp_addlogin()' to
	** 'sp_addlogin_rep()'.  This will cause the Replication Server to
	** execute, at the target ASE, the system procedure
	** 'sp_addlogin_rep()' which knows how to properly process the
	** encrypted password.
	*/
	select @passwd = password
	from master.dbo.syslogins
	where suid = @insertsuid

	/*
	** If the 'master' database is marked for replication, the T-SQL
	** built-in 'logexec()' will log for replication the execution
	** instance of this system procedure.  Otherwise, the T-SQL
	** built-in 'logexec()' is a no-op.
	*/
	if (logexec(1) != 1)
	begin
		raiserror 17756, "sp_addlogin", "master"
		select @returncode = 1
	end
end

if @returncode = 0
begin
	/* UN-lock the account after successful update */
	/* except in case of user sybmail a MAPI requirement. */
	if (@loginame != "sybmail")
	begin
		execute @returncode = sp_locklogin @loginame, "unlock"

	end
end
else
begin
	/*
	** Delete relevant syslogins and sysattribute login information
	** for this login, in order to backout.
	*/
	delete from master.dbo.syslogins where name = @loginame
	delete from master.dbo.sysattributes 
		where class = @passeclass AND object = @insertsuid
		AND object_cinfo = "login"



end

if @returncode = 0
                begin
                        /*
                        ** 17264, "New login created."
                        */
                        exec sp_getmessage 17264, @msg output
                        print @msg
                end


close sync_cursor
deallocate cursor sync_cursor

return (@returncode)

clean_all:

	return (1)

go
grant execute on dbo.sp_addlogin to public /*dbo*/
go
