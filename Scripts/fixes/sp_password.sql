use sybsystemprocs
go
if exists(select 1
		from sysobjects
		where id=object_id('dbo.sp_password')
		and type='P')
	drop procedure dbo.sp_password
go

/* Sccsid = "%Z% generic/sproc/src/%M% %I% %G%" */
/* 	4.8	1.1	06/14/90	sproc/src/password */

/*
** Generated by spgenmsgs.pl on Thu Feb  2 00:39:18 2006 
*/
/*
** raiserror Messages for password [Total 3]
**
** 17260, "Can't run %1! from within a transaction."
** 17720, "Error:  Unable to set the Password."
** 17756, "The execution of the stored procedure '%1!' in database '%2!' was aborted because there was an error in writing the replication log record."
*/
/*
** sp_getmessage Messages for password [Total 1]
**
** 17721, "Password correctly set."
*/
/*
** End spgenmsgs.pl output.
*/

/* 
** IMPORTANT: Please read the following instructions before
**   making changes to this stored procedure.
**
**	To make this stored procedure compatible with High Availability (HA),
**	changes to certain system tables must be propagated 
**	to the companion server under some conditions.
**	The tables include (but are not limited to):
**		syslogins, sysservers, sysattributes, systimeranges,
**		sysresourcelimits, sysalternates, sysdatabases,
**		syslanguages, sysremotelogins, sysloginroles,
**		sysalternates (master DB only), systypes (master DB only),
**		sysusers (master DB only), sysprotects (master DB only)
**	please refer to the HA documentation for detail.
**
**	Here is what you need to do: 
**	For each insert/update/delete statement, add three sections to
**	-- start HA transaction prior to the statement
**	-- add the statement
**	-- add HA synchronization code to propagate the change to the companion
**
**	For example, if you are adding 
**		insert master.dbo.syslogins ......
**	the code should look like:
**	1. Before that SQL statement:
**		
**	2. Now, the SQL statement:
**		insert master.dbo.syslogins ......
**	3. Add a HA synchronization section right after the SQL statement:
**		
**
**	You may need to do similar change for each built-in function you
**	want to add.
**
**	Finally, add a separate part at a place where it can not
**	be reached by the normal execution path:
**	clean_all:
**		
**		return (1)
*/

create procedure sp_password
@caller_password varchar(255) = NULL,	/* the current password of caller */
@new_password    varchar(256) = NULL,	/* the new password of the target acct*/
					/* a length of 256 is required to test if
					** user entered a passwd > 255 chars.
					*/
@loginame        varchar(255) = NULL,	/* user to change password on */
@immediate	 int = 0		/* if not 0, change the password in
					** all running processes for loginame.
					*/
as

declare @returncode int
declare @msg  varchar(1024)
declare @HA_CERTIFIED tinyint   /* Is the SP HA certified ? */
declare @retstat  int


select @HA_CERTIFIED = 0




/* check to see if we are using HA specific SP for a HA enabled server */
exec @retstat = sp_ha_check_certified 'sp_password', @HA_CERTIFIED
if (@retstat != 0)
        return (1)

/*
** Do not allow this system procedure to be run from within a transaction
** to avoid creating a multi-database transaction where the 'master'
** database is not the co-ordinating database.
*/
if @@trancount > 0
begin
	/*
	** 17260, "Can't run %1! from within a transaction."
	*/
	raiserror 17260, "sp_password"
	return (1)
end
else
begin
	set chained off
end

set transaction isolation level 1

/*
**  Encrypt and store the input @new_password.
**  @caller_password will be checked against the password of the caller.
**  set_password() builtin will print out nice messages.
*/
select @returncode = set_password(@caller_password, @new_password, @loginame, @immediate)




if (@returncode = 0)
begin
	/*
	** 17720, "Error:  Unable to set the Password."
	*/
	raiserror 17720
	return (1)
end
else
begin
	/*
	** Before we log our system procedure execution instance,
	** re-initialize the '@caller_password' parameter to NULL and the
	** '@new_password' parameter to the encrypted form of the password.
	** This prevents the passwords from being stored in clear text in
	** the transaction log as well as in the Replication Server stable
	** queues.
	**
	** When the ASE RepAgent Thread sends the system procedure
	** execution instance to the Replication Server, the ASE RepAgent
	** will re-name the system procedure from 'sp_password()' to
	** 'sp_password_rep()'.  This will cause the Replication Server to
	** execute, at the target ASE, the system procedure
	** 'sp_password_rep()' which knows how to properly process the
	** encrypted password.
	*/
	select @caller_password = NULL

	if (@loginame is not NULL)
	begin
		select @new_password = password
		from master.dbo.syslogins
		where name = @loginame
	end
	else
	begin
		select @new_password = password
		from master.dbo.syslogins
		where suid = suser_id()
	end

	/*
	** If the 'master' database is marked for replication, the T-SQL
	** built-in 'logexec()' will log for replication the execution
	** instance of this system procedure.  Otherwise, the T-SQL
	** built-in 'logexec()' is a no-op.
	*/
	if (logexec(1) != 1)
	begin
		raiserror 17756, "sp_password", "master"
		return (1)
	end

	/*
	** 17721, "Password correctly set."
	*/
	exec sp_getmessage 17721, @msg output
	print @msg
	return (0)
end


go
grant execute on dbo.sp_password to public /*dbo*/
go
